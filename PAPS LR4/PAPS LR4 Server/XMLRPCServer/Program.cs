using System;
using System.Collections;
using Nwc.XmlRpc;

namespace PAPS_LR4_Server
{
    class Program
    {
        static int port = 8031;
        static void Main(string[] args)
        {
            // создание и запуск сервера
            XmlRpcServer server = new XmlRpcServer(port);
            server.Add("sample", new Program());
            Console.WriteLine("Сервер запущен");
            server.Start(); //Запуск сервера
        }

        // функция обработки квадратной матрицы
        public ArrayList massiv(ArrayList list, int n)
        {
            Console.WriteLine("Началась обработка массива...\n");
            int k = 0;
            //создание списка для хранения измененной матрицы
            ArrayList result = new ArrayList(2 * n * n + 1);
            result.Clear();
            //  создание двух двумерных массивов и их заполнение
            int[,] mas = new int[n, n];
            int[,] mas1 = new int[n, n];

            for (int i = 0; i < n; i++)
            {
                for (int j = 0; j < n; j++)
                {
                    mas1[i, j] = mas[i, j] = Convert.ToInt32(list[k]);
                    k++;
                }
            }

            // нахождение минимального элемента в массиве и его индексов
            int min = 999999999, i_min = -1, j_min = -1;
            for (int i = 0; i < n; i++)
            {
                for (int j = 0; j < n; j++)
                {
                    if (mas[i, j] < min)
                    {
                        min = mas[i, j];
                        i_min = i;
                        j_min = j;
                    }
                }
            }
            result.Add(min); // добавить минимальный массив в список

            //После нахождения минимального элемента в массиве диагональ можно расположить несколькими способами.
            // Пусть дана матрица:
            // 2 1 2
            // 2 2 2
            // 2 2 2
            // Минимальный элемент - единица. Диагональ содержащая данный элемент может быть два варианта. 
            // Заменим элементы диагонали на 0.
            // Первый вариант диагонали. 
            // Если расположить матрицу в координатной плоскости, то диагональ создает с положительным направлением оси ОХ тупой угол
            // 2 0 2
            // 2 2 0
            // 2 2 2            
            // Второй вариант диагонали. 
            // Если расположить матрицу в координатной плоскости, то диагональ создает с положительным направлением оси ОХ острый угол
            // 2 0 2
            // 0 2 2
            // 2 2 2
            // Пользователю предоставим два варианта


            // Первый вариант диагонали. 
            // Если расположить матрицу в координатной плоскости, то диагональ создает с положительным направлением оси ОХ тупой угол
            // перевод диагонали с минимальные элементы в 0. 
            // Элемент массива будет является частью диагонали, если разница между его индексом и индексом минимального равна
            bool index = false;
            for (int i = 0; i < n; i++)
            {
                for (int j = 0; j < n; j++)
                {
                    if (i - i_min == j - j_min)
                    {
                        mas[i, j] = 0;
                        if (j == 0) index = true;
                    }
                }
            }

            // возведение в квадрат элементов ниже диагонали с нулями
            // Работа с матрицей идет построчно начиная слева. 
            //Если 0 расположен в первом столбце, то просто переписываем элементы до нуля. После встречи первого нуля со следующей строки:
            //Все элементы до нуля в строке возводим в квадрат
            int s1 = 0;
            for (int i = 0; i < n; i++)
            {
                int s = 0;
                for (int j = 0; j < n; j++)
                {
                    if (index)
                    {
                        if (mas[i, j] == 0) s1 = 1;
                        if ((mas[i, j] != 0) && (s == 0) && (s1 == 1))
                        { mas[i, j] = mas[i, j] * mas[i, j]; }
                        else s = 1;
                        result.Add(mas[i, j]);
                    }
                    else
                    {
                        if ((mas[i, j] != 0) && (s == 0))
                        { mas[i, j] = mas[i, j] * mas[i, j]; }
                        else s = 1;
                        result.Add(mas[i, j]);
                    }
                }
            }

            // Второй вариант диагонали. 
            // Если расположить матрицу в координатной плоскости, то диагональ создает с положительным направлением оси ОХ острый угол
            // перевод диагонали с минимальные элементы в 0
            // элементы массива будут является частью диагонали, если сумма его индексов равна сумме индексов минимального элемента

            bool index1 = false;
            for (int i = 0; i < n; i++)
            {
                for (int j = 0; j < n; j++)
                {
                    if (i + j == i_min + j_min)
                    {
                        mas1[i, j] = 0;
                        if (j == n - 1) index1 = true;
                    }
                }
            }
            // возведение в квадрат элементов ниже диагонали с нулями
            // Работа с матрицей идет построчно, начиная справа. 
            //Если 0 расположен в последнем столбце, то просто переписываем элементы до нуля. После встречи первого нуля со следующей строки:
            //Все элементы до нуля в строке возводим в квадрат
            int s2 = 0;
            for (int i = 0; i < n; i++)
            {
                int s = 0;
                for (int j = n - 1; j >= 0; j--)
                {
                    if (index1)
                    {
                        if (mas1[i, j] == 0) s2 = 1;

                        if ((mas1[i, j] != 0) && (s == 0) && (s2 == 1))
                        { mas1[i, j] = mas1[i, j] * mas1[i, j]; }
                        else s = 1;
                    }
                    else
                    {
                        if ((mas1[i, j] != 0) && (s == 0))
                        { mas1[i, j] = mas1[i, j] * mas1[i, j]; }
                        else s = 1;
                    }
                }
                for (int j = 0; j < n; j++)
                    result.Add(mas1[i, j]);
            }

            Console.WriteLine("... Обработка массива закончилась\n");
            return result;  // возвращаем список
        }
    }
}
